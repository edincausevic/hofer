var app = angular.module("aktuelles", ["firebase", "ngSanitize"]);


app.filter('reverse', function(){

  return function(date) {
    var amerDate = new Date(date);
    return amerDate.getDate() + '/' + (amerDate.getMonth() + 1)  + '/' + amerDate.getFullYear()
  }
});

app.controller('aktuellesController', ['$scope', '$sce', '$timeout', '$firebaseArray',  function($scope, $sce, $timeout, $firebaseArray){

    $scope.$sce = $sce;

    //CONECT TO DATABASE AND SAVE IT ON $SCOPT.DATA
    var ref = firebase.database().ref();
    $scope.rawData = $firebaseArray(ref);
    
    
    $scope.rawData.$loaded().then(function(){

        var newArray = $scope.rawData;
        
        newArray.sort(function(a,b){
          // Turn your strings into dates, and then subtract them
          // to get a value that is either negative, positive, or zero.
          return new Date(b.date) - new Date(a.date);
        });  
      
        $scope.data = newArray.reverse();  

        $scope.preload = true;
        
    });


    
 
    $scope.addImage = function() {

        var uploadBtn = document.getElementById('upload-btn');
        var uploadBar = document.getElementById('show-upload');

        uploadBtn.addEventListener('change', function(e){

            // get the file
            var file = e.target.files[0];

            // create a storege refs
            var storageRef = firebase.storage().ref('images/'  + file.name);   
            $scope.image = 'images/' + file.name;
            // upload file
            var task = storageRef.put(file);

            task.on('state_changed', function(snapshot){
              // Observe state change events such as progress, pause, and resume
              // Get task progress, including the number of bytes uploaded and the total number of bytes to be uploaded
              var progress = (snapshot.bytesTransferred / snapshot.totalBytes) * 100;
              $scope.uploadImageProgressMsg = 'Image Upload progress: ' + progress + '%';
              //console.log('Image Upload progress: ' + progress + '%')
              $('#uploading-image-gif').show(200);
              $scope.uploadState = true;
            }, function(error) {
              // Handle unsuccessful uploads
            }, function() {
              // Handle successful uploads on complete
              // For instance, get the download URL: https://firebasestorage.googleapis.com/...
              var downloadURL = task.snapshot.downloadURL;
              $('#uploading-image-gif').hide(200);
              $scope.uploadState = false;
              $scope.imageUrl = downloadURL;
             
            });
        });
    }
    $scope.addImage();

    $scope.showMenu = function() {
        $scope.backTrans=true; 
        $scope.addMessage=true;
    }

    $scope.article = {};

    $scope.uploadState = false;
    $scope.addArticle = function() {

        if ($scope.uploadState == false) {
            var date = new Date();
           
             if ($scope.article.date == undefined || $scope.article.date.length == 0) {
                var today = date.getDate() + '/' + (date.getMonth() + 1)  + '/' + date.getFullYear() ;
                
                $scope.article.date = today;
            }

            $scope.article.message = $scope.article.message.replace('%img%', '<img src="'+$scope.imageUrl+'" class="actuelles-image">');
           
            $scope.data.$add($scope.article);
            $scope.backTrans = false;
            $scope.addMessage = false;
            $scope.article = {}; 
        }
    }
  
    $scope.removeArticle = function(item) {
        if (confirm('Are you sure you want to delte this article?')) {
            var index = $scope.data.indexOf(item);
            $scope.data.$remove(item);
        }
    }

    $scope.editArticle = function(item) {
        $scope.backTrans = true;
        $scope.addMessage = true;
        $scope.article = item;
        $scope.thisArticle = item;
        $scope.editing = true;
    }

    $scope.saveEdit = function() {
        $scope.article = $scope.thisArticle;
        $scope.data.$save($scope.article);
        $scope.backTrans = false;
        $scope.addMessage = false;
        $scope.article = {}; 
    }

}]);




// send email
$('#email-form').on('submit', function(e){
    e.preventDefault();
    
    var check = true;
    // check for inputs
    function checkForm(el, msg, err) {

        var input = $(el);
        var error = $(err);
        
        if ( input.val().length === 0 ) {
            error.html(msg);
            input.select();
            check = false;
        }else { error.html('&nbsp;'); }
    }
    checkForm('#name', 'Bitte geben Sie einen Namen', '#name-error');
    checkForm('#email', 'Bitte geben Sie eine E-Mail', '#email-error');
    checkForm('#subject', 'Bitte geben Sie einen Betreff', '#subject-error');
    checkForm('textarea', 'Textbox ist leer', '#text-error');
    
    // stop the form
    if ( check === true ) {
        // store data from inputs
        var name = $('#name').val(),
            email = $('#email').val(),
            subject = $('#subject').val(),
            text = $('textarea').val();
        
        function emptyInput() {
            $('#name').val("");
            $('#email').val("");
            $('#subject').val("");
            $('textarea').val("");
        }

        // send data
        $.ajax({
            type: 'POST',
            url: 'email.php',
            data: { name: name, email: email, subject: subject, text: text },
            success: function(response) {
                if ( response == "success" ) {
                    emptyInput();
                    makeMsg('Herzlichen Dank f√ºr Ihre Nachricht.', '#80bd34');
                }else {
                    emptyInput();
                    makeMsg('Hoppla! Etwas ist schief gelaufen. Bitte versuche es erneut!', '#fa4641');
                }
            }
        });
        
    }else { return false; } 
});

// make msg after mail is send    
function makeMsg( msg, color ) {

    var message = '<div class="mail-msg">' +msg+ '</div>';
    $('#email-message').html( message );
    $('.mail-msg').css('color', color);
    $('.mail-msg').fadeIn(300);
    setTimeout(function(){$('.mail-msg').html('&nbsp;');},3000);
}    

$('.futter-btn').on('click', function(){

    $('.footer-info').slideToggle();
    $("html, body").animate({ scrollTop: $(document).height() }, 1000);
    $(this).hide();
});

function xhr(callback) {

  var data = [
    {
        id        : 1,
        smallImg  :"img/gal1.jpg",
        largeImg  :"img/gal1-big.jpg",
        text      :"",
        imageNumber: 1
    },
    {
        id        : 2,
        smallImg  :"img/gal2.jpg",
        largeImg  :"img/gal2-big.jpg",
        text      :"",
        imageNumber: 2
    },
    {
        id        : 3,
        smallImg  :"img/gal3.jpg",
        largeImg  :"img/gal3-big.jpg",
        text      :"",
        imageNumber: 3
    },
    {
        id        : 4,
        smallImg  :"img/gal4.jpg",
        largeImg  :"img/gal4-big.jpg",
        text      :"",
        imageNumber: 4
    },
    {
        id        : 5,
        smallImg  :"img/gal5.jpg",
        largeImg  :"img/gal5-big.jpg",
        text      :"",
        imageNumber: 5
    },
    {
        id        : 6,
        smallImg  :"img/gal6.jpg",
        largeImg  :"img/gal6-big.jpg",
        text      :"",
        imageNumber: 6
    }
]


callback(data);
}


// load images in gallery section
function loadImages(data) {

    // select gallery container
    var gallery = $('.img-gallery');

    // create image li items with json info and append it to gallery
    $.each(data, function(name, obj) {

        // create li item
        var li = '<li>' +
                    '<img src="' +obj.smallImg+ '" id="' +obj.id+ '" alt="Image"/>' +
                    '<div><i class="fa fa-plus-circle" aria-hidden="true"></i></div>' +
                 '</li>';
        gallery.append(li);
    });
}

xhr(loadImages);


// gallery functions
function gallery(data) {

    var galleryContainer = $('#show-image');

    // show image on click
    $(document).on('click', '.img-gallery li', function(){

        var imgContainer = $('#big-image');
        var id = parseInt( $(this).find('img').attr('id') );

        $.each(data, function(name, obj){
            if ( obj.id === id ) {
                $('#big-image').attr('src', obj.largeImg);
                $('#image-info').html(obj.text);
                $('#image-number').html(obj.imageNumber + '/6');
            }
        });

        $('#show-image').fadeIn(300);
    });

    // hide gallery with click on dark background
    galleryContainer.on('click', function(e) {
        if (e.target === this ) {
            $(this).fadeOut(300);
        }
    });
    // hide gallery with click on x icon
    $('#close-image').on('click', function(){ galleryContainer.fadeOut(300)});

    // change image on right
    $('#right').on('click', function(){
        // save number of image
        var id = parseInt($(this).closest('#image-container')
                                 .find('#image-number')
                                 .html().slice(0,1));
        var counter = id;
        if ( counter == 6 ) counter = 0;
        counter++;

        changeImage(counter)
    });

    // change image on right
    $('#left').on('click', function(){
        // save number of image
        var id = parseInt($(this).closest('#image-container')
                          .find('#image-number')
                          .html().slice(0,1));
        var counter = id;
        if ( counter == 1 ) counter = 7;
        counter--;

        changeImage(counter)
    });

    function changeImage(counter) {
        $.each(data, function(name, obj){
            if ( obj.id === counter ) {
                $('#big-image').attr('src', obj.largeImg);
                $('#image-info').html(obj.text);
                $('#image-number').html(obj.id + '/6');
            }
        });
    }
}
xhr(gallery);


// ACUTUELLES GALLERY
$(document).on('click', ".actuelles-image", function(){

    var $this = $(this);
    var $gal = $('.aktuelles-gal');
    var $galImg = $('.akt-image-big');

    $gal.fadeIn(300);
    var src = $this.attr('src');
    $galImg.attr('src', src);

    $gal.on('click', function(e){ $(this).fadeOut(300); });
});
$(function(){

// exsicute this code only on main page 
if ( !$('body').is('#aktuelles') ) {
// start slideshow - headerImgAnimation( change image every ); 
headerImgAnimation(5000);     
    
function headerImgAnimation(time){

    var header = $('header');
    var bltPoints = $('#bltPoints li');
    var counter = 1
    var pause = false;
    
    //change image on time
    var interval = setInterval(function(){

        if ( pause === false ) {
            
            // reset counter
            if ( counter === 3 ) counter = 0;
            //change header image with counter
            counter++;
            header.attr('class', 'background' + counter);
            // change bullet points with counter
            bltPoints.removeClass();
            $('#bp' + counter).attr('class', 'bpActive');
        }    
    },time); 
    
    //change image on click
    bltPoints.on('click', function(){
        
        // change buttons icons
        bltPoints.removeClass();
        $(this).addClass('bpActive');
        //change image
        var thisId = $(this).attr('id');
        counter = parseInt(thisId.slice(-1));
        header.attr('class', 'background' + counter);
    });
    
    // puse and resume the slideshow
    bltPoints.on('mouseover mouseout', function(e) {
        
        // pause the slideshow
        if ( e.type === 'mouseover' ) {
            pause = true;
        }
        // resume the slideshow
        if ( e.type === 'mouseout' ) {
            pause = false;
        }
    });
};
    

// header background image preloader
function imagePreloader() {

    for ( var i = 0; i < arguments.length; i++ ) {
        $('<img/>').attr('src', arguments[i]);
    }
}    
    
imagePreloader('css/img/header-bc2.jpg', 'css/img/header-bc3.jpg');    
    
}    
});
var ms_ie = false;
var ua = window.navigator.userAgent;
var old_ie = ua.indexOf('MSIE ');
var new_ie = ua.indexOf('Trident/');

if ((old_ie > -1) || (new_ie > -1)) {
    ms_ie = true;
}

if ( ms_ie ) {
    $('#header-hr').css('margin', '0');
}
"use strict";
(function(root, factory) {
    if(typeof exports === 'object') {
        module.exports = factory();
    }
    else if(typeof define === 'function' && define.amd) {
        define(['jquery', 'googlemaps!'], factory);
    }
    else {
        root.GMaps = factory();
    }


}(this, function() {

    /*!
 * GMaps.js v0.4.18
 * http://hpneo.github.com/gmaps/
 *
 * Copyright 2015, Gustavo Leon
 * Released under the MIT License.
 */

    if (!(typeof window.google === 'object' && window.google.maps)) {
        throw 'Google Maps API is required. Please register the following JavaScript library http://maps.google.com/maps/api/js?sensor=true.'
    }

    var extend_object = function(obj, new_obj) {
        var name;

        if (obj === new_obj) {
            return obj;
        }

        for (name in new_obj) {
            obj[name] = new_obj[name];
        }

        return obj;
    };

    var replace_object = function(obj, replace) {
        var name;

        if (obj === replace) {
            return obj;
        }

        for (name in replace) {
            if (obj[name] != undefined) {
                obj[name] = replace[name];
            }
        }

        return obj;
    };

    var array_map = function(array, callback) {
        var original_callback_params = Array.prototype.slice.call(arguments, 2),
            array_return = [],
            array_length = array.length,
            i;

        if (Array.prototype.map && array.map === Array.prototype.map) {
            array_return = Array.prototype.map.call(array, function(item) {
                var callback_params = original_callback_params.slice(0);
                callback_params.splice(0, 0, item);

                return callback.apply(this, callback_params);
            });
        }
        else {
            for (i = 0; i < array_length; i++) {
                callback_params = original_callback_params;
                callback_params.splice(0, 0, array[i]);
                array_return.push(callback.apply(this, callback_params));
            }
        }

        return array_return;
    };

    var array_flat = function(array) {
        var new_array = [],
            i;

        for (i = 0; i < array.length; i++) {
            new_array = new_array.concat(array[i]);
        }

        return new_array;
    };

    var coordsToLatLngs = function(coords, useGeoJSON) {
        var first_coord = coords[0],
            second_coord = coords[1];

        if (useGeoJSON) {
            first_coord = coords[1];
            second_coord = coords[0];
        }

        return new google.maps.LatLng(first_coord, second_coord);
    };

    var arrayToLatLng = function(coords, useGeoJSON) {
        var i;

        for (i = 0; i < coords.length; i++) {
            if (!(coords[i] instanceof google.maps.LatLng)) {
                if (coords[i].length > 0 && typeof(coords[i][0]) === "object") {
                    coords[i] = arrayToLatLng(coords[i], useGeoJSON);
                }
                else {
                    coords[i] = coordsToLatLngs(coords[i], useGeoJSON);
                }
            }
        }

        return coords;
    };


    var getElementsByClassName = function (class_name, context) {

        var element,
            _class = class_name.replace('.', '');

        if ('jQuery' in this && context) {
            element = $("." + _class, context)[0];
        } else {
            element = document.getElementsByClassName(_class)[0];
        }
        return element;

    };

    var getElementById = function(id, context) {
        var element,
            id = id.replace('#', '');

        if ('jQuery' in window && context) {
            element = $('#' + id, context)[0];
        } else {
            element = document.getElementById(id);
        };

        return element;
    };

    var findAbsolutePosition = function(obj)  {
        var curleft = 0,
            curtop = 0;

        if (obj.offsetParent) {
            do {
                curleft += obj.offsetLeft;
                curtop += obj.offsetTop;
            } while (obj = obj.offsetParent);
        }

        return [curleft, curtop];
    };

    var GMaps = (function(global) {
        "use strict";

        var doc = document;

        var GMaps = function(options) {
            if (!this) return new GMaps(options);

            options.zoom = options.zoom || 15;
            options.mapType = options.mapType || 'roadmap';

            var self = this,
                i,
                events_that_hide_context_menu = [
                    'bounds_changed', 'center_changed', 'click', 'dblclick', 'drag',
                    'dragend', 'dragstart', 'idle', 'maptypeid_changed', 'projection_changed',
                    'resize', 'tilesloaded', 'zoom_changed'
                ],
                events_that_doesnt_hide_context_menu = ['mousemove', 'mouseout', 'mouseover'],
                options_to_be_deleted = ['el', 'lat', 'lng', 'mapType', 'width', 'height', 'markerClusterer', 'enableNewStyle'],
                identifier = options.el || options.div,
                markerClustererFunction = options.markerClusterer,
                mapType = google.maps.MapTypeId[options.mapType.toUpperCase()],
                map_center = new google.maps.LatLng(options.lat, options.lng),
                zoomControl = options.zoomControl || true,
                zoomControlOpt = options.zoomControlOpt || {
                    style: 'DEFAULT',
                    position: 'TOP_LEFT'
                },
                zoomControlStyle = zoomControlOpt.style || 'DEFAULT',
                zoomControlPosition = zoomControlOpt.position || 'TOP_LEFT',
                panControl = options.panControl || true,
                mapTypeControl = options.mapTypeControl || true,
                scaleControl = options.scaleControl || true,
                streetViewControl = options.streetViewControl || true,
                overviewMapControl = overviewMapControl || true,
                map_options = {},
                map_base_options = {
                    zoom: this.zoom,
                    center: map_center,
                    mapTypeId: mapType
                },
                map_controls_options = {
                    panControl: panControl,
                    zoomControl: zoomControl,
                    zoomControlOptions: {
                        style: google.maps.ZoomControlStyle[zoomControlStyle],
                        position: google.maps.ControlPosition[zoomControlPosition]
                    },
                    mapTypeControl: mapTypeControl,
                    scaleControl: scaleControl,
                    streetViewControl: streetViewControl,
                    overviewMapControl: overviewMapControl
                };

            if (typeof(options.el) === 'string' || typeof(options.div) === 'string') {

                if (identifier.indexOf("#") > -1) {
                    this.el = getElementById(identifier, options.context);
                } else {
                    this.el = getElementsByClassName.apply(this, [identifier, options.context]);
                }

            } else {
                this.el = identifier;
            }

            if (typeof(this.el) === 'undefined' || this.el === null) {
                throw 'No element defined.';
            }

            window.context_menu = window.context_menu || {};
            window.context_menu[self.el.id] = {};

            this.controls = [];
            this.overlays = [];
            this.layers = []; // array with kml/georss and fusiontables layers, can be as many
            this.singleLayers = {}; // object with the other layers, only one per layer
            this.markers = [];
            this.polylines = [];
            this.routes = [];
            this.polygons = [];
            this.infoWindow = null;
            this.overlay_el = null;
            this.zoom = options.zoom;
            this.registered_events = {};

            this.el.style.width = options.width || this.el.scrollWidth || this.el.offsetWidth;
            this.el.style.height = options.height || this.el.scrollHeight || this.el.offsetHeight;

            google.maps.visualRefresh = options.enableNewStyle;

            for (i = 0; i < options_to_be_deleted.length; i++) {
                delete options[options_to_be_deleted[i]];
            }

            if(options.disableDefaultUI != true) {
                map_base_options = extend_object(map_base_options, map_controls_options);
            }

            map_options = extend_object(map_base_options, options);

            for (i = 0; i < events_that_hide_context_menu.length; i++) {
                delete map_options[events_that_hide_context_menu[i]];
            }

            for (i = 0; i < events_that_doesnt_hide_context_menu.length; i++) {
                delete map_options[events_that_doesnt_hide_context_menu[i]];
            }

            this.map = new google.maps.Map(this.el, map_options);

            if (markerClustererFunction) {
                this.markerClusterer = markerClustererFunction.apply(this, [this.map]);
            }

            var buildContextMenuHTML = function(control, e) {
                var html = '',
                    options = window.context_menu[self.el.id][control];

                for (var i in options){
                    if (options.hasOwnProperty(i)) {
                        var option = options[i];

                        html += '<li><a id="' + control + '_' + i + '" href="#">' + option.title + '</a></li>';
                    }
                }

                if (!getElementById('gmaps_context_menu')) return;

                var context_menu_element = getElementById('gmaps_context_menu');

                context_menu_element.innerHTML = html;

                var context_menu_items = context_menu_element.getElementsByTagName('a'),
                    context_menu_items_count = context_menu_items.length,
                    i;

                for (i = 0; i < context_menu_items_count; i++) {
                    var context_menu_item = context_menu_items[i];

                    var assign_menu_item_action = function(ev){
                        ev.preventDefault();

                        options[this.id.replace(control + '_', '')].action.apply(self, [e]);
                        self.hideContextMenu();
                    };

                    google.maps.event.clearListeners(context_menu_item, 'click');
                    google.maps.event.addDomListenerOnce(context_menu_item, 'click', assign_menu_item_action, false);
                }

                var position = findAbsolutePosition.apply(this, [self.el]),
                    left = position[0] + e.pixel.x - 15,
                    top = position[1] + e.pixel.y- 15;

                context_menu_element.style.left = left + "px";
                context_menu_element.style.top = top + "px";

                context_menu_element.style.display = 'block';
            };

            this.buildContextMenu = function(control, e) {
                if (control === 'marker') {
                    e.pixel = {};

                    var overlay = new google.maps.OverlayView();
                    overlay.setMap(self.map);

                    overlay.draw = function() {
                        var projection = overlay.getProjection(),
                            position = e.marker.getPosition();

                        e.pixel = projection.fromLatLngToContainerPixel(position);

                        buildContextMenuHTML(control, e);
                    };
                }
                else {
                    buildContextMenuHTML(control, e);
                }
            };

            this.setContextMenu = function(options) {
                window.context_menu[self.el.id][options.control] = {};

                var i,
                    ul = doc.createElement('ul');

                for (i in options.options) {
                    if (options.options.hasOwnProperty(i)) {
                        var option = options.options[i];

                        window.context_menu[self.el.id][options.control][option.name] = {
                            title: option.title,
                            action: option.action
                        };
                    }
                }

                ul.id = 'gmaps_context_menu';
                ul.style.display = 'none';
                ul.style.position = 'absolute';
                ul.style.minWidth = '100px';
                ul.style.background = 'white';
                ul.style.listStyle = 'none';
                ul.style.padding = '8px';
                ul.style.boxShadow = '2px 2px 6px #ccc';

                doc.body.appendChild(ul);

                var context_menu_element = getElementById('gmaps_context_menu')

                google.maps.event.addDomListener(context_menu_element, 'mouseout', function(ev) {
                    if (!ev.relatedTarget || !this.contains(ev.relatedTarget)) {
                        window.setTimeout(function(){
                            context_menu_element.style.display = 'none';
                        }, 400);
                    }
                }, false);
            };

            this.hideContextMenu = function() {
                var context_menu_element = getElementById('gmaps_context_menu');

                if (context_menu_element) {
                    context_menu_element.style.display = 'none';
                }
            };

            var setupListener = function(object, name) {
                google.maps.event.addListener(object, name, function(e){
                    if (e == undefined) {
                        e = this;
                    }

                    options[name].apply(this, [e]);

                    self.hideContextMenu();
                });
            };

            //google.maps.event.addListener(this.map, 'idle', this.hideContextMenu);
            google.maps.event.addListener(this.map, 'zoom_changed', this.hideContextMenu);

            for (var ev = 0; ev < events_that_hide_context_menu.length; ev++) {
                var name = events_that_hide_context_menu[ev];

                if (name in options) {
                    setupListener(this.map, name);
                }
            }

            for (var ev = 0; ev < events_that_doesnt_hide_context_menu.length; ev++) {
                var name = events_that_doesnt_hide_context_menu[ev];

                if (name in options) {
                    setupListener(this.map, name);
                }
            }

            google.maps.event.addListener(this.map, 'rightclick', function(e) {
                if (options.rightclick) {
                    options.rightclick.apply(this, [e]);
                }

                if(window.context_menu[self.el.id]['map'] != undefined) {
                    self.buildContextMenu('map', e);
                }
            });

            this.refresh = function() {
                google.maps.event.trigger(this.map, 'resize');
            };

            this.fitZoom = function() {
                var latLngs = [],
                    markers_length = this.markers.length,
                    i;

                for (i = 0; i < markers_length; i++) {
                    if(typeof(this.markers[i].visible) === 'boolean' && this.markers[i].visible) {
                        latLngs.push(this.markers[i].getPosition());
                    }
                }

                this.fitLatLngBounds(latLngs);
            };

            this.fitLatLngBounds = function(latLngs) {
                var total = latLngs.length,
                    bounds = new google.maps.LatLngBounds(),
                    i;

                for(i = 0; i < total; i++) {
                    bounds.extend(latLngs[i]);
                }

                this.map.fitBounds(bounds);
            };

            this.setCenter = function(lat, lng, callback) {
                this.map.panTo(new google.maps.LatLng(lat, lng));

                if (callback) {
                    callback();
                }
            };

            this.getElement = function() {
                return this.el;
            };

            this.zoomIn = function(value) {
                value = value || 1;

                this.zoom = this.map.getZoom() + value;
                this.map.setZoom(this.zoom);
            };

            this.zoomOut = function(value) {
                value = value || 1;

                this.zoom = this.map.getZoom() - value;
                this.map.setZoom(this.zoom);
            };

            var native_methods = [],
                method;

            for (method in this.map) {
                if (typeof(this.map[method]) == 'function' && !this[method]) {
                    native_methods.push(method);
                }
            }

            for (i = 0; i < native_methods.length; i++) {
                (function(gmaps, scope, method_name) {
                    gmaps[method_name] = function(){
                        return scope[method_name].apply(scope, arguments);
                    };
                })(this, this.map, native_methods[i]);
            }
        };

        return GMaps;
    })(this);

    GMaps.prototype.createControl = function(options) {
        var control = document.createElement('div');

        control.style.cursor = 'pointer';

        if (options.disableDefaultStyles !== true) {
            control.style.fontFamily = 'Roboto, Arial, sans-serif';
            control.style.fontSize = '11px';
            control.style.boxShadow = 'rgba(0, 0, 0, 0.298039) 0px 1px 4px -1px';
        }

        for (var option in options.style) {
            control.style[option] = options.style[option];
        }

        if (options.id) {
            control.id = options.id;
        }

        if (options.classes) {
            control.className = options.classes;
        }

        if (options.content) {
            if (typeof options.content === 'string') {
                control.innerHTML = options.content;
            }
            else if (options.content instanceof HTMLElement) {
                control.appendChild(options.content);
            }
        }

        if (options.position) {
            control.position = google.maps.ControlPosition[options.position.toUpperCase()];
        }

        for (var ev in options.events) {
            (function(object, name) {
                google.maps.event.addDomListener(object, name, function(){
                    options.events[name].apply(this, [this]);
                });
            })(control, ev);
        }

        control.index = 1;

        return control;
    };

    GMaps.prototype.addControl = function(options) {
        var control = this.createControl(options);

        this.controls.push(control);
        this.map.controls[control.position].push(control);

        return control;
    };

    GMaps.prototype.removeControl = function(control) {
        var position = null,
            i;

        for (i = 0; i < this.controls.length; i++) {
            if (this.controls[i] == control) {
                position = this.controls[i].position;
                this.controls.splice(i, 1);
            }
        }

        if (position) {
            for (i = 0; i < this.map.controls.length; i++) {
                var controlsForPosition = this.map.controls[control.position];

                if (controlsForPosition.getAt(i) == control) {
                    controlsForPosition.removeAt(i);

                    break;
                }
            }
        }

        return control;
    };

    GMaps.prototype.createMarker = function(options) {
        if (options.lat == undefined && options.lng == undefined && options.position == undefined) {
            throw 'No latitude or longitude defined.';
        }

        var self = this,
            details = options.details,
            fences = options.fences,
            outside = options.outside,
            base_options = {
                position: new google.maps.LatLng(options.lat, options.lng),
                map: null
            },
            marker_options = extend_object(base_options, options);

        delete marker_options.lat;
        delete marker_options.lng;
        delete marker_options.fences;
        delete marker_options.outside;

        var marker = new google.maps.Marker(marker_options);

        marker.fences = fences;

        if (options.infoWindow) {
            marker.infoWindow = new google.maps.InfoWindow(options.infoWindow);

            var info_window_events = ['closeclick', 'content_changed', 'domready', 'position_changed', 'zindex_changed'];

            for (var ev = 0; ev < info_window_events.length; ev++) {
                (function(object, name) {
                    if (options.infoWindow[name]) {
                        google.maps.event.addListener(object, name, function(e){
                            options.infoWindow[name].apply(this, [e]);
                        });
                    }
                })(marker.infoWindow, info_window_events[ev]);
            }
        }

        var marker_events = ['animation_changed', 'clickable_changed', 'cursor_changed', 'draggable_changed', 'flat_changed', 'icon_changed', 'position_changed', 'shadow_changed', 'shape_changed', 'title_changed', 'visible_changed', 'zindex_changed'];

        var marker_events_with_mouse = ['dblclick', 'drag', 'dragend', 'dragstart', 'mousedown', 'mouseout', 'mouseover', 'mouseup'];

        for (var ev = 0; ev < marker_events.length; ev++) {
            (function(object, name) {
                if (options[name]) {
                    google.maps.event.addListener(object, name, function(){
                        options[name].apply(this, [this]);
                    });
                }
            })(marker, marker_events[ev]);
        }

        for (var ev = 0; ev < marker_events_with_mouse.length; ev++) {
            (function(map, object, name) {
                if (options[name]) {
                    google.maps.event.addListener(object, name, function(me){
                        if(!me.pixel){
                            me.pixel = map.getProjection().fromLatLngToPoint(me.latLng)
                        }

                        options[name].apply(this, [me]);
                    });
                }
            })(this.map, marker, marker_events_with_mouse[ev]);
        }

        google.maps.event.addListener(marker, 'click', function() {
            this.details = details;

            if (options.click) {
                options.click.apply(this, [this]);
            }

            if (marker.infoWindow) {
                self.hideInfoWindows();
                marker.infoWindow.open(self.map, marker);
            }
        });

        google.maps.event.addListener(marker, 'rightclick', function(e) {
            e.marker = this;

            if (options.rightclick) {
                options.rightclick.apply(this, [e]);
            }

            if (window.context_menu[self.el.id]['marker'] != undefined) {
                self.buildContextMenu('marker', e);
            }
        });

        if (marker.fences) {
            google.maps.event.addListener(marker, 'dragend', function() {
                self.checkMarkerGeofence(marker, function(m, f) {
                    outside(m, f);
                });
            });
        }

        return marker;
    };

    GMaps.prototype.addMarker = function(options) {
        var marker;
        if(options.hasOwnProperty('gm_accessors_')) {
            // Native google.maps.Marker object
            marker = options;
        }
        else {
            if ((options.hasOwnProperty('lat') && options.hasOwnProperty('lng')) || options.position) {
                marker = this.createMarker(options);
            }
            else {
                throw 'No latitude or longitude defined.';
            }
        }

        marker.setMap(this.map);

        if(this.markerClusterer) {
            this.markerClusterer.addMarker(marker);
        }

        this.markers.push(marker);

        GMaps.fire('marker_added', marker, this);

        return marker;
    };

    GMaps.prototype.addMarkers = function(array) {
        for (var i = 0, marker; marker=array[i]; i++) {
            this.addMarker(marker);
        }

        return this.markers;
    };

    GMaps.prototype.hideInfoWindows = function() {
        for (var i = 0, marker; marker = this.markers[i]; i++){
            if (marker.infoWindow) {
                marker.infoWindow.close();
            }
        }
    };

    GMaps.prototype.removeMarker = function(marker) {
        for (var i = 0; i < this.markers.length; i++) {
            if (this.markers[i] === marker) {
                this.markers[i].setMap(null);
                this.markers.splice(i, 1);

                if(this.markerClusterer) {
                    this.markerClusterer.removeMarker(marker);
                }

                GMaps.fire('marker_removed', marker, this);

                break;
            }
        }

        return marker;
    };

    GMaps.prototype.removeMarkers = function (collection) {
        var new_markers = [];

        if (typeof collection == 'undefined') {
            for (var i = 0; i < this.markers.length; i++) {
                var marker = this.markers[i];
                marker.setMap(null);

                if(this.markerClusterer) {
                    this.markerClusterer.removeMarker(marker);
                }

                GMaps.fire('marker_removed', marker, this);
            }

            this.markers = new_markers;
        }
        else {
            for (var i = 0; i < collection.length; i++) {
                var index = this.markers.indexOf(collection[i]);

                if (index > -1) {
                    var marker = this.markers[index];
                    marker.setMap(null);

                    if(this.markerClusterer) {
                        this.markerClusterer.removeMarker(marker);
                    }

                    GMaps.fire('marker_removed', marker, this);
                }
            }

            for (var i = 0; i < this.markers.length; i++) {
                var marker = this.markers[i];
                if (marker.getMap() != null) {
                    new_markers.push(marker);
                }
            }

            this.markers = new_markers;
        }
    };

    GMaps.prototype.drawOverlay = function(options) {
        var overlay = new google.maps.OverlayView(),
            auto_show = true;

        overlay.setMap(this.map);

        if (options.auto_show != null) {
            auto_show = options.auto_show;
        }

        overlay.onAdd = function() {
            var el = document.createElement('div');

            el.style.borderStyle = "none";
            el.style.borderWidth = "0px";
            el.style.position = "absolute";
            el.style.zIndex = 100;
            el.innerHTML = options.content;

            overlay.el = el;

            if (!options.layer) {
                options.layer = 'overlayLayer';
            }

            var panes = this.getPanes(),
                overlayLayer = panes[options.layer],
                stop_overlay_events = ['contextmenu', 'DOMMouseScroll', 'dblclick', 'mousedown'];

            overlayLayer.appendChild(el);

            for (var ev = 0; ev < stop_overlay_events.length; ev++) {
                (function(object, name) {
                    google.maps.event.addDomListener(object, name, function(e){
                        if (navigator.userAgent.toLowerCase().indexOf('msie') != -1 && document.all) {
                            e.cancelBubble = true;
                            e.returnValue = false;
                        }
                        else {
                            e.stopPropagation();
                        }
                    });
                })(el, stop_overlay_events[ev]);
            }

            if (options.click) {
                panes.overlayMouseTarget.appendChild(overlay.el);
                google.maps.event.addDomListener(overlay.el, 'click', function() {
                    options.click.apply(overlay, [overlay]);
                });
            }

            google.maps.event.trigger(this, 'ready');
        };

        overlay.draw = function() {
            var projection = this.getProjection(),
                pixel = projection.fromLatLngToDivPixel(new google.maps.LatLng(options.lat, options.lng));

            options.horizontalOffset = options.horizontalOffset || 0;
            options.verticalOffset = options.verticalOffset || 0;

            var el = overlay.el,
                content = el.children[0],
                content_height = content.clientHeight,
                content_width = content.clientWidth;

            switch (options.verticalAlign) {
                case 'top':
                    el.style.top = (pixel.y - content_height + options.verticalOffset) + 'px';
                    break;
                default:
                case 'middle':
                    el.style.top = (pixel.y - (content_height / 2) + options.verticalOffset) + 'px';
                    break;
                case 'bottom':
                    el.style.top = (pixel.y + options.verticalOffset) + 'px';
                    break;
            }

            switch (options.horizontalAlign) {
                case 'left':
                    el.style.left = (pixel.x - content_width + options.horizontalOffset) + 'px';
                    break;
                default:
                case 'center':
                    el.style.left = (pixel.x - (content_width / 2) + options.horizontalOffset) + 'px';
                    break;
                case 'right':
                    el.style.left = (pixel.x + options.horizontalOffset) + 'px';
                    break;
            }

            el.style.display = auto_show ? 'block' : 'none';

            if (!auto_show) {
                options.show.apply(this, [el]);
            }
        };

        overlay.onRemove = function() {
            var el = overlay.el;

            if (options.remove) {
                options.remove.apply(this, [el]);
            }
            else {
                overlay.el.parentNode.removeChild(overlay.el);
                overlay.el = null;
            }
        };

        this.overlays.push(overlay);
        return overlay;
    };

    GMaps.prototype.removeOverlay = function(overlay) {
        for (var i = 0; i < this.overlays.length; i++) {
            if (this.overlays[i] === overlay) {
                this.overlays[i].setMap(null);
                this.overlays.splice(i, 1);

                break;
            }
        }
    };

    GMaps.prototype.removeOverlays = function() {
        for (var i = 0, item; item = this.overlays[i]; i++) {
            item.setMap(null);
        }

        this.overlays = [];
    };

    GMaps.prototype.drawPolyline = function(options) {
        var path = [],
            points = options.path;

        if (points.length) {
            if (points[0][0] === undefined) {
                path = points;
            }
            else {
                for (var i = 0, latlng; latlng = points[i]; i++) {
                    path.push(new google.maps.LatLng(latlng[0], latlng[1]));
                }
            }
        }

        var polyline_options = {
            map: this.map,
            path: path,
            strokeColor: options.strokeColor,
            strokeOpacity: options.strokeOpacity,
            strokeWeight: options.strokeWeight,
            geodesic: options.geodesic,
            clickable: true,
            editable: false,
            visible: true
        };

        if (options.hasOwnProperty("clickable")) {
            polyline_options.clickable = options.clickable;
        }

        if (options.hasOwnProperty("editable")) {
            polyline_options.editable = options.editable;
        }

        if (options.hasOwnProperty("icons")) {
            polyline_options.icons = options.icons;
        }

        if (options.hasOwnProperty("zIndex")) {
            polyline_options.zIndex = options.zIndex;
        }

        var polyline = new google.maps.Polyline(polyline_options);

        var polyline_events = ['click', 'dblclick', 'mousedown', 'mousemove', 'mouseout', 'mouseover', 'mouseup', 'rightclick'];

        for (var ev = 0; ev < polyline_events.length; ev++) {
            (function(object, name) {
                if (options[name]) {
                    google.maps.event.addListener(object, name, function(e){
                        options[name].apply(this, [e]);
                    });
                }
            })(polyline, polyline_events[ev]);
        }

        this.polylines.push(polyline);

        GMaps.fire('polyline_added', polyline, this);

        return polyline;
    };

    GMaps.prototype.removePolyline = function(polyline) {
        for (var i = 0; i < this.polylines.length; i++) {
            if (this.polylines[i] === polyline) {
                this.polylines[i].setMap(null);
                this.polylines.splice(i, 1);

                GMaps.fire('polyline_removed', polyline, this);

                break;
            }
        }
    };

    GMaps.prototype.removePolylines = function() {
        for (var i = 0, item; item = this.polylines[i]; i++) {
            item.setMap(null);
        }

        this.polylines = [];
    };

    GMaps.prototype.drawCircle = function(options) {
        options =  extend_object({
            map: this.map,
            center: new google.maps.LatLng(options.lat, options.lng)
        }, options);

        delete options.lat;
        delete options.lng;

        var polygon = new google.maps.Circle(options),
            polygon_events = ['click', 'dblclick', 'mousedown', 'mousemove', 'mouseout', 'mouseover', 'mouseup', 'rightclick'];

        for (var ev = 0; ev < polygon_events.length; ev++) {
            (function(object, name) {
                if (options[name]) {
                    google.maps.event.addListener(object, name, function(e){
                        options[name].apply(this, [e]);
                    });
                }
            })(polygon, polygon_events[ev]);
        }

        this.polygons.push(polygon);

        return polygon;
    };

    GMaps.prototype.drawRectangle = function(options) {
        options = extend_object({
            map: this.map
        }, options);

        var latLngBounds = new google.maps.LatLngBounds(
            new google.maps.LatLng(options.bounds[0][0], options.bounds[0][1]),
            new google.maps.LatLng(options.bounds[1][0], options.bounds[1][1])
        );

        options.bounds = latLngBounds;

        var polygon = new google.maps.Rectangle(options),
            polygon_events = ['click', 'dblclick', 'mousedown', 'mousemove', 'mouseout', 'mouseover', 'mouseup', 'rightclick'];

        for (var ev = 0; ev < polygon_events.length; ev++) {
            (function(object, name) {
                if (options[name]) {
                    google.maps.event.addListener(object, name, function(e){
                        options[name].apply(this, [e]);
                    });
                }
            })(polygon, polygon_events[ev]);
        }

        this.polygons.push(polygon);

        return polygon;
    };

    GMaps.prototype.drawPolygon = function(options) {
        var useGeoJSON = false;

        if(options.hasOwnProperty("useGeoJSON")) {
            useGeoJSON = options.useGeoJSON;
        }

        delete options.useGeoJSON;

        options = extend_object({
            map: this.map
        }, options);

        if (useGeoJSON == false) {
            options.paths = [options.paths.slice(0)];
        }

        if (options.paths.length > 0) {
            if (options.paths[0].length > 0) {
                options.paths = array_flat(array_map(options.paths, arrayToLatLng, useGeoJSON));
            }
        }

        var polygon = new google.maps.Polygon(options),
            polygon_events = ['click', 'dblclick', 'mousedown', 'mousemove', 'mouseout', 'mouseover', 'mouseup', 'rightclick'];

        for (var ev = 0; ev < polygon_events.length; ev++) {
            (function(object, name) {
                if (options[name]) {
                    google.maps.event.addListener(object, name, function(e){
                        options[name].apply(this, [e]);
                    });
                }
            })(polygon, polygon_events[ev]);
        }

        this.polygons.push(polygon);

        GMaps.fire('polygon_added', polygon, this);

        return polygon;
    };

    GMaps.prototype.removePolygon = function(polygon) {
        for (var i = 0; i < this.polygons.length; i++) {
            if (this.polygons[i] === polygon) {
                this.polygons[i].setMap(null);
                this.polygons.splice(i, 1);

                GMaps.fire('polygon_removed', polygon, this);

                break;
            }
        }
    };

    GMaps.prototype.removePolygons = function() {
        for (var i = 0, item; item = this.polygons[i]; i++) {
            item.setMap(null);
        }

        this.polygons = [];
    };

    GMaps.prototype.getFromFusionTables = function(options) {
        var events = options.events;

        delete options.events;

        var fusion_tables_options = options,
            layer = new google.maps.FusionTablesLayer(fusion_tables_options);

        for (var ev in events) {
            (function(object, name) {
                google.maps.event.addListener(object, name, function(e) {
                    events[name].apply(this, [e]);
                });
            })(layer, ev);
        }

        this.layers.push(layer);

        return layer;
    };

    GMaps.prototype.loadFromFusionTables = function(options) {
        var layer = this.getFromFusionTables(options);
        layer.setMap(this.map);

        return layer;
    };

    GMaps.prototype.getFromKML = function(options) {
        var url = options.url,
            events = options.events;

        delete options.url;
        delete options.events;

        var kml_options = options,
            layer = new google.maps.KmlLayer(url, kml_options);

        for (var ev in events) {
            (function(object, name) {
                google.maps.event.addListener(object, name, function(e) {
                    events[name].apply(this, [e]);
                });
            })(layer, ev);
        }

        this.layers.push(layer);

        return layer;
    };

    GMaps.prototype.loadFromKML = function(options) {
        var layer = this.getFromKML(options);
        layer.setMap(this.map);

        return layer;
    };

    GMaps.prototype.addLayer = function(layerName, options) {
        //var default_layers = ['weather', 'clouds', 'traffic', 'transit', 'bicycling', 'panoramio', 'places'];
        options = options || {};
        var layer;

        switch(layerName) {
            case 'weather': this.singleLayers.weather = layer = new google.maps.weather.WeatherLayer();
                break;
            case 'clouds': this.singleLayers.clouds = layer = new google.maps.weather.CloudLayer();
                break;
            case 'traffic': this.singleLayers.traffic = layer = new google.maps.TrafficLayer();
                break;
            case 'transit': this.singleLayers.transit = layer = new google.maps.TransitLayer();
                break;
            case 'bicycling': this.singleLayers.bicycling = layer = new google.maps.BicyclingLayer();
                break;
            case 'panoramio':
                this.singleLayers.panoramio = layer = new google.maps.panoramio.PanoramioLayer();
                layer.setTag(options.filter);
                delete options.filter;

                //click event
                if (options.click) {
                    google.maps.event.addListener(layer, 'click', function(event) {
                        options.click(event);
                        delete options.click;
                    });
                }
                break;
            case 'places':
                this.singleLayers.places = layer = new google.maps.places.PlacesService(this.map);

                //search, nearbySearch, radarSearch callback, Both are the same
                if (options.search || options.nearbySearch || options.radarSearch) {
                    var placeSearchRequest  = {
                        bounds : options.bounds || null,
                        keyword : options.keyword || null,
                        location : options.location || null,
                        name : options.name || null,
                        radius : options.radius || null,
                        rankBy : options.rankBy || null,
                        types : options.types || null
                    };

                    if (options.radarSearch) {
                        layer.radarSearch(placeSearchRequest, options.radarSearch);
                    }

                    if (options.search) {
                        layer.search(placeSearchRequest, options.search);
                    }

                    if (options.nearbySearch) {
                        layer.nearbySearch(placeSearchRequest, options.nearbySearch);
                    }
                }

                //textSearch callback
                if (options.textSearch) {
                    var textSearchRequest  = {
                        bounds : options.bounds || null,
                        location : options.location || null,
                        query : options.query || null,
                        radius : options.radius || null
                    };

                    layer.textSearch(textSearchRequest, options.textSearch);
                }
                break;
        }

        if (layer !== undefined) {
            if (typeof layer.setOptions == 'function') {
                layer.setOptions(options);
            }
            if (typeof layer.setMap == 'function') {
                layer.setMap(this.map);
            }

            return layer;
        }
    };

    GMaps.prototype.removeLayer = function(layer) {
        if (typeof(layer) == "string" && this.singleLayers[layer] !== undefined) {
            this.singleLayers[layer].setMap(null);

            delete this.singleLayers[layer];
        }
        else {
            for (var i = 0; i < this.layers.length; i++) {
                if (this.layers[i] === layer) {
                    this.layers[i].setMap(null);
                    this.layers.splice(i, 1);

                    break;
                }
            }
        }
    };

    var travelMode, unitSystem;

    GMaps.prototype.getRoutes = function(options) {
        switch (options.travelMode) {
            case 'bicycling':
                travelMode = google.maps.TravelMode.BICYCLING;
                break;
            case 'transit':
                travelMode = google.maps.TravelMode.TRANSIT;
                break;
            case 'driving':
                travelMode = google.maps.TravelMode.DRIVING;
                break;
            default:
                travelMode = google.maps.TravelMode.WALKING;
                break;
        }

        if (options.unitSystem === 'imperial') {
            unitSystem = google.maps.UnitSystem.IMPERIAL;
        }
        else {
            unitSystem = google.maps.UnitSystem.METRIC;
        }

        var base_options = {
            avoidHighways: false,
            avoidTolls: false,
            optimizeWaypoints: false,
            waypoints: []
        },
            request_options =  extend_object(base_options, options);

        request_options.origin = /string/.test(typeof options.origin) ? options.origin : new google.maps.LatLng(options.origin[0], options.origin[1]);
        request_options.destination = /string/.test(typeof options.destination) ? options.destination : new google.maps.LatLng(options.destination[0], options.destination[1]);
        request_options.travelMode = travelMode;
        request_options.unitSystem = unitSystem;

        delete request_options.callback;
        delete request_options.error;

        var self = this,
            service = new google.maps.DirectionsService();

        service.route(request_options, function(result, status) {
            if (status === google.maps.DirectionsStatus.OK) {
                for (var r in result.routes) {
                    if (result.routes.hasOwnProperty(r)) {
                        self.routes.push(result.routes[r]);
                    }
                }

                if (options.callback) {
                    options.callback(self.routes);
                }
            }
            else {
                if (options.error) {
                    options.error(result, status);
                }
            }
        });
    };

    GMaps.prototype.removeRoutes = function() {
        this.routes = [];
    };

    GMaps.prototype.getElevations = function(options) {
        options = extend_object({
            locations: [],
            path : false,
            samples : 256
        }, options);

        if (options.locations.length > 0) {
            if (options.locations[0].length > 0) {
                options.locations = array_flat(array_map([options.locations], arrayToLatLng,  false));
            }
        }

        var callback = options.callback;
        delete options.callback;

        var service = new google.maps.ElevationService();

        //location request
        if (!options.path) {
            delete options.path;
            delete options.samples;

            service.getElevationForLocations(options, function(result, status) {
                if (callback && typeof(callback) === "function") {
                    callback(result, status);
                }
            });
            //path request
        } else {
            var pathRequest = {
                path : options.locations,
                samples : options.samples
            };

            service.getElevationAlongPath(pathRequest, function(result, status) {
                if (callback && typeof(callback) === "function") {
                    callback(result, status);
                }
            });
        }
    };

    GMaps.prototype.cleanRoute = GMaps.prototype.removePolylines;

    GMaps.prototype.drawRoute = function(options) {
        var self = this;

        this.getRoutes({
            origin: options.origin,
            destination: options.destination,
            travelMode: options.travelMode,
            waypoints: options.waypoints,
            unitSystem: options.unitSystem,
            error: options.error,
            callback: function(e) {
                if (e.length > 0) {
                    var polyline_options = {
                        path: e[e.length - 1].overview_path,
                        strokeColor: options.strokeColor,
                        strokeOpacity: options.strokeOpacity,
                        strokeWeight: options.strokeWeight
                    };

                    if (options.hasOwnProperty("icons")) {
                        polyline_options.icons = options.icons;
                    }

                    self.drawPolyline(polyline_options);

                    if (options.callback) {
                        options.callback(e[e.length - 1]);
                    }
                }
            }
        });
    };

    GMaps.prototype.travelRoute = function(options) {
        if (options.origin && options.destination) {
            this.getRoutes({
                origin: options.origin,
                destination: options.destination,
                travelMode: options.travelMode,
                waypoints : options.waypoints,
                unitSystem: options.unitSystem,
                error: options.error,
                callback: function(e) {
                    //start callback
                    if (e.length > 0 && options.start) {
                        options.start(e[e.length - 1]);
                    }

                    //step callback
                    if (e.length > 0 && options.step) {
                        var route = e[e.length - 1];
                        if (route.legs.length > 0) {
                            var steps = route.legs[0].steps;
                            for (var i = 0, step; step = steps[i]; i++) {
                                step.step_number = i;
                                options.step(step, (route.legs[0].steps.length - 1));
                            }
                        }
                    }

                    //end callback
                    if (e.length > 0 && options.end) {
                        options.end(e[e.length - 1]);
                    }
                }
            });
        }
        else if (options.route) {
            if (options.route.legs.length > 0) {
                var steps = options.route.legs[0].steps;
                for (var i = 0, step; step = steps[i]; i++) {
                    step.step_number = i;
                    options.step(step);
                }
            }
        }
    };

    GMaps.prototype.drawSteppedRoute = function(options) {
        var self = this;

        if (options.origin && options.destination) {
            this.getRoutes({
                origin: options.origin,
                destination: options.destination,
                travelMode: options.travelMode,
                waypoints : options.waypoints,
                error: options.error,
                callback: function(e) {
                    //start callback
                    if (e.length > 0 && options.start) {
                        options.start(e[e.length - 1]);
                    }

                    //step callback
                    if (e.length > 0 && options.step) {
                        var route = e[e.length - 1];
                        if (route.legs.length > 0) {
                            var steps = route.legs[0].steps;
                            for (var i = 0, step; step = steps[i]; i++) {
                                step.step_number = i;
                                var polyline_options = {
                                    path: step.path,
                                    strokeColor: options.strokeColor,
                                    strokeOpacity: options.strokeOpacity,
                                    strokeWeight: options.strokeWeight
                                };

                                if (options.hasOwnProperty("icons")) {
                                    polyline_options.icons = options.icons;
                                }

                                self.drawPolyline(polyline_options);
                                options.step(step, (route.legs[0].steps.length - 1));
                            }
                        }
                    }

                    //end callback
                    if (e.length > 0 && options.end) {
                        options.end(e[e.length - 1]);
                    }
                }
            });
        }
        else if (options.route) {
            if (options.route.legs.length > 0) {
                var steps = options.route.legs[0].steps;
                for (var i = 0, step; step = steps[i]; i++) {
                    step.step_number = i;
                    var polyline_options = {
                        path: step.path,
                        strokeColor: options.strokeColor,
                        strokeOpacity: options.strokeOpacity,
                        strokeWeight: options.strokeWeight
                    };

                    if (options.hasOwnProperty("icons")) {
                        polyline_options.icons = options.icons;
                    }

                    self.drawPolyline(polyline_options);
                    options.step(step);
                }
            }
        }
    };

    GMaps.Route = function(options) {
        this.origin = options.origin;
        this.destination = options.destination;
        this.waypoints = options.waypoints;

        this.map = options.map;
        this.route = options.route;
        this.step_count = 0;
        this.steps = this.route.legs[0].steps;
        this.steps_length = this.steps.length;

        var polyline_options = {
            path: new google.maps.MVCArray(),
            strokeColor: options.strokeColor,
            strokeOpacity: options.strokeOpacity,
            strokeWeight: options.strokeWeight
        };

        if (options.hasOwnProperty("icons")) {
            polyline_options.icons = options.icons;
        }

        this.polyline = this.map.drawPolyline(polyline_options).getPath();
    };

    GMaps.Route.prototype.getRoute = function(options) {
        var self = this;

        this.map.getRoutes({
            origin : this.origin,
            destination : this.destination,
            travelMode : options.travelMode,
            waypoints : this.waypoints || [],
            error: options.error,
            callback : function() {
                self.route = e[0];

                if (options.callback) {
                    options.callback.call(self);
                }
            }
        });
    };

    GMaps.Route.prototype.back = function() {
        if (this.step_count > 0) {
            this.step_count--;
            var path = this.route.legs[0].steps[this.step_count].path;

            for (var p in path){
                if (path.hasOwnProperty(p)){
                    this.polyline.pop();
                }
            }
        }
    };

    GMaps.Route.prototype.forward = function() {
        if (this.step_count < this.steps_length) {
            var path = this.route.legs[0].steps[this.step_count].path;

            for (var p in path){
                if (path.hasOwnProperty(p)){
                    this.polyline.push(path[p]);
                }
            }
            this.step_count++;
        }
    };

    GMaps.prototype.checkGeofence = function(lat, lng, fence) {
        return fence.containsLatLng(new google.maps.LatLng(lat, lng));
    };

    GMaps.prototype.checkMarkerGeofence = function(marker, outside_callback) {
        if (marker.fences) {
            for (var i = 0, fence; fence = marker.fences[i]; i++) {
                var pos = marker.getPosition();
                if (!this.checkGeofence(pos.lat(), pos.lng(), fence)) {
                    outside_callback(marker, fence);
                }
            }
        }
    };

    GMaps.prototype.toImage = function(options) {
        var options = options || {},
            static_map_options = {};

        static_map_options['size'] = options['size'] || [this.el.clientWidth, this.el.clientHeight];
        static_map_options['lat'] = this.getCenter().lat();
        static_map_options['lng'] = this.getCenter().lng();

        if (this.markers.length > 0) {
            static_map_options['markers'] = [];

            for (var i = 0; i < this.markers.length; i++) {
                static_map_options['markers'].push({
                    lat: this.markers[i].getPosition().lat(),
                    lng: this.markers[i].getPosition().lng()
                });
            }
        }

        if (this.polylines.length > 0) {
            var polyline = this.polylines[0];

            static_map_options['polyline'] = {};
            static_map_options['polyline']['path'] = google.maps.geometry.encoding.encodePath(polyline.getPath());
            static_map_options['polyline']['strokeColor'] = polyline.strokeColor
            static_map_options['polyline']['strokeOpacity'] = polyline.strokeOpacity
            static_map_options['polyline']['strokeWeight'] = polyline.strokeWeight
        }

        return GMaps.staticMapURL(static_map_options);
    };

    GMaps.staticMapURL = function(options){
        var parameters = [],
            data,
            static_root = (location.protocol === 'file:' ? 'http:' : location.protocol ) + '//maps.googleapis.com/maps/api/staticmap';

        if (options.url) {
            static_root = options.url;
            delete options.url;
        }

        static_root += '?';

        var markers = options.markers;

        delete options.markers;

        if (!markers && options.marker) {
            markers = [options.marker];
            delete options.marker;
        }

        var styles = options.styles;

        delete options.styles;

        var polyline = options.polyline;
        delete options.polyline;

        /** Map options **/
        if (options.center) {
            parameters.push('center=' + options.center);
            delete options.center;
        }
        else if (options.address) {
            parameters.push('center=' + options.address);
            delete options.address;
        }
        else if (options.lat) {
            parameters.push(['center=', options.lat, ',', options.lng].join(''));
            delete options.lat;
            delete options.lng;
        }
        else if (options.visible) {
            var visible = encodeURI(options.visible.join('|'));
            parameters.push('visible=' + visible);
        }

        var size = options.size;
        if (size) {
            if (size.join) {
                size = size.join('x');
            }
            delete options.size;
        }
        else {
            size = '630x300';
        }
        parameters.push('size=' + size);

        if (!options.zoom && options.zoom !== false) {
            options.zoom = 15;
        }

        var sensor = options.hasOwnProperty('sensor') ? !!options.sensor : true;
        delete options.sensor;
        parameters.push('sensor=' + sensor);

        for (var param in options) {
            if (options.hasOwnProperty(param)) {
                parameters.push(param + '=' + options[param]);
            }
        }

        /** Markers **/
        if (markers) {
            var marker, loc;

            for (var i = 0; data = markers[i]; i++) {
                marker = [];

                if (data.size && data.size !== 'normal') {
                    marker.push('size:' + data.size);
                    delete data.size;
                }
                else if (data.icon) {
                    marker.push('icon:' + encodeURI(data.icon));
                    delete data.icon;
                }

                if (data.color) {
                    marker.push('color:' + data.color.replace('#', '0x'));
                    delete data.color;
                }

                if (data.label) {
                    marker.push('label:' + data.label[0].toUpperCase());
                    delete data.label;
                }

                loc = (data.address ? data.address : data.lat + ',' + data.lng);
                delete data.address;
                delete data.lat;
                delete data.lng;

                for(var param in data){
                    if (data.hasOwnProperty(param)) {
                        marker.push(param + ':' + data[param]);
                    }
                }

                if (marker.length || i === 0) {
                    marker.push(loc);
                    marker = marker.join('|');
                    parameters.push('markers=' + encodeURI(marker));
                }
                // New marker without styles
                else {
                    marker = parameters.pop() + encodeURI('|' + loc);
                    parameters.push(marker);
                }
            }
        }

        /** Map Styles **/
        if (styles) {
            for (var i = 0; i < styles.length; i++) {
                var styleRule = [];
                if (styles[i].featureType){
                    styleRule.push('feature:' + styles[i].featureType.toLowerCase());
                }

                if (styles[i].elementType) {
                    styleRule.push('element:' + styles[i].elementType.toLowerCase());
                }

                for (var j = 0; j < styles[i].stylers.length; j++) {
                    for (var p in styles[i].stylers[j]) {
                        var ruleArg = styles[i].stylers[j][p];
                        if (p == 'hue' || p == 'color') {
                            ruleArg = '0x' + ruleArg.substring(1);
                        }
                        styleRule.push(p + ':' + ruleArg);
                    }
                }

                var rule = styleRule.join('|');
                if (rule != '') {
                    parameters.push('style=' + rule);
                }
            }
        }

        /** Polylines **/
        function parseColor(color, opacity) {
            if (color[0] === '#'){
                color = color.replace('#', '0x');

                if (opacity) {
                    opacity = parseFloat(opacity);
                    opacity = Math.min(1, Math.max(opacity, 0));
                    if (opacity === 0) {
                        return '0x00000000';
                    }
                    opacity = (opacity * 255).toString(16);
                    if (opacity.length === 1) {
                        opacity += opacity;
                    }

                    color = color.slice(0,8) + opacity;
                }
            }
            return color;
        }

        if (polyline) {
            data = polyline;
            polyline = [];

            if (data.strokeWeight) {
                polyline.push('weight:' + parseInt(data.strokeWeight, 10));
            }

            if (data.strokeColor) {
                var color = parseColor(data.strokeColor, data.strokeOpacity);
                polyline.push('color:' + color);
            }

            if (data.fillColor) {
                var fillcolor = parseColor(data.fillColor, data.fillOpacity);
                polyline.push('fillcolor:' + fillcolor);
            }

            var path = data.path;
            if (path.join) {
                for (var j=0, pos; pos=path[j]; j++) {
                    polyline.push(pos.join(','));
                }
            }
            else {
                polyline.push('enc:' + path);
            }

            polyline = polyline.join('|');
            parameters.push('path=' + encodeURI(polyline));
        }

        /** Retina support **/
        var dpi = window.devicePixelRatio || 1;
        parameters.push('scale=' + dpi);

        parameters = parameters.join('&');
        return static_root + parameters;
    };

    GMaps.prototype.addMapType = function(mapTypeId, options) {
        if (options.hasOwnProperty("getTileUrl") && typeof(options["getTileUrl"]) == "function") {
            options.tileSize = options.tileSize || new google.maps.Size(256, 256);

            var mapType = new google.maps.ImageMapType(options);

            this.map.mapTypes.set(mapTypeId, mapType);
        }
        else {
            throw "'getTileUrl' function required.";
        }
    };

    GMaps.prototype.addOverlayMapType = function(options) {
        if (options.hasOwnProperty("getTile") && typeof(options["getTile"]) == "function") {
            var overlayMapTypeIndex = options.index;

            delete options.index;

            this.map.overlayMapTypes.insertAt(overlayMapTypeIndex, options);
        }
        else {
            throw "'getTile' function required.";
        }
    };

    GMaps.prototype.removeOverlayMapType = function(overlayMapTypeIndex) {
        this.map.overlayMapTypes.removeAt(overlayMapTypeIndex);
    };

    GMaps.prototype.addStyle = function(options) {
        var styledMapType = new google.maps.StyledMapType(options.styles, { name: options.styledMapName });

        this.map.mapTypes.set(options.mapTypeId, styledMapType);
    };

    GMaps.prototype.setStyle = function(mapTypeId) {
        this.map.setMapTypeId(mapTypeId);
    };

    GMaps.prototype.createPanorama = function(streetview_options) {
        if (!streetview_options.hasOwnProperty('lat') || !streetview_options.hasOwnProperty('lng')) {
            streetview_options.lat = this.getCenter().lat();
            streetview_options.lng = this.getCenter().lng();
        }

        this.panorama = GMaps.createPanorama(streetview_options);

        this.map.setStreetView(this.panorama);

        return this.panorama;
    };

    GMaps.createPanorama = function(options) {
        var el = getElementById(options.el, options.context);

        options.position = new google.maps.LatLng(options.lat, options.lng);

        delete options.el;
        delete options.context;
        delete options.lat;
        delete options.lng;

        var streetview_events = ['closeclick', 'links_changed', 'pano_changed', 'position_changed', 'pov_changed', 'resize', 'visible_changed'],
            streetview_options = extend_object({visible : true}, options);

        for (var i = 0; i < streetview_events.length; i++) {
            delete streetview_options[streetview_events[i]];
        }

        var panorama = new google.maps.StreetViewPanorama(el, streetview_options);

        for (var i = 0; i < streetview_events.length; i++) {
            (function(object, name) {
                if (options[name]) {
                    google.maps.event.addListener(object, name, function(){
                        options[name].apply(this);
                    });
                }
            })(panorama, streetview_events[i]);
        }

        return panorama;
    };

    GMaps.prototype.on = function(event_name, handler) {
        return GMaps.on(event_name, this, handler);
    };

    GMaps.prototype.off = function(event_name) {
        GMaps.off(event_name, this);
    };

    GMaps.custom_events = ['marker_added', 'marker_removed', 'polyline_added', 'polyline_removed', 'polygon_added', 'polygon_removed', 'geolocated', 'geolocation_failed'];

    GMaps.on = function(event_name, object, handler) {
        if (GMaps.custom_events.indexOf(event_name) == -1) {
            if(object instanceof GMaps) object = object.map; 
            return google.maps.event.addListener(object, event_name, handler);
        }
        else {
            var registered_event = {
                handler : handler,
                eventName : event_name
            };

            object.registered_events[event_name] = object.registered_events[event_name] || [];
            object.registered_events[event_name].push(registered_event);

            return registered_event;
        }
    };

    GMaps.off = function(event_name, object) {
        if (GMaps.custom_events.indexOf(event_name) == -1) {
            if(object instanceof GMaps) object = object.map; 
            google.maps.event.clearListeners(object, event_name);
        }
        else {
            object.registered_events[event_name] = [];
        }
    };

    GMaps.fire = function(event_name, object, scope) {
        if (GMaps.custom_events.indexOf(event_name) == -1) {
            google.maps.event.trigger(object, event_name, Array.prototype.slice.apply(arguments).slice(2));
        }
        else {
            if(event_name in scope.registered_events) {
                var firing_events = scope.registered_events[event_name];

                for(var i = 0; i < firing_events.length; i++) {
                    (function(handler, scope, object) {
                        handler.apply(scope, [object]);
                    })(firing_events[i]['handler'], scope, object);
                }
            }
        }
    };

    GMaps.geolocate = function(options) {
        var complete_callback = options.always || options.complete;

        if (navigator.geolocation) {
            navigator.geolocation.getCurrentPosition(function(position) {
                options.success(position);

                if (complete_callback) {
                    complete_callback();
                }
            }, function(error) {
                options.error(error);

                if (complete_callback) {
                    complete_callback();
                }
            }, options.options);
        }
        else {
            options.not_supported();

            if (complete_callback) {
                complete_callback();
            }
        }
    };

    GMaps.geocode = function(options) {
        this.geocoder = new google.maps.Geocoder();
        var callback = options.callback;
        if (options.hasOwnProperty('lat') && options.hasOwnProperty('lng')) {
            options.latLng = new google.maps.LatLng(options.lat, options.lng);
        }

        delete options.lat;
        delete options.lng;
        delete options.callback;

        this.geocoder.geocode(options, function(results, status) {
            callback(results, status);
        });
    };

    //==========================
    // Polygon containsLatLng
    // https://github.com/tparkin/Google-Maps-Point-in-Polygon
    // Poygon getBounds extension - google-maps-extensions
    // http://code.google.com/p/google-maps-extensions/source/browse/google.maps.Polygon.getBounds.js
    if (!google.maps.Polygon.prototype.getBounds) {
        google.maps.Polygon.prototype.getBounds = function(latLng) {
            var bounds = new google.maps.LatLngBounds();
            var paths = this.getPaths();
            var path;

            for (var p = 0; p < paths.getLength(); p++) {
                path = paths.getAt(p);
                for (var i = 0; i < path.getLength(); i++) {
                    bounds.extend(path.getAt(i));
                }
            }

            return bounds;
        };
    }

    if (!google.maps.Polygon.prototype.containsLatLng) {
        // Polygon containsLatLng - method to determine if a latLng is within a polygon
        google.maps.Polygon.prototype.containsLatLng = function(latLng) {
            // Exclude points outside of bounds as there is no way they are in the poly
            var bounds = this.getBounds();

            if (bounds !== null && !bounds.contains(latLng)) {
                return false;
            }

            // Raycast point in polygon method
            var inPoly = false;

            var numPaths = this.getPaths().getLength();
            for (var p = 0; p < numPaths; p++) {
                var path = this.getPaths().getAt(p);
                var numPoints = path.getLength();
                var j = numPoints - 1;

                for (var i = 0; i < numPoints; i++) {
                    var vertex1 = path.getAt(i);
                    var vertex2 = path.getAt(j);

                    if (vertex1.lng() < latLng.lng() && vertex2.lng() >= latLng.lng() || vertex2.lng() < latLng.lng() && vertex1.lng() >= latLng.lng()) {
                        if (vertex1.lat() + (latLng.lng() - vertex1.lng()) / (vertex2.lng() - vertex1.lng()) * (vertex2.lat() - vertex1.lat()) < latLng.lat()) {
                            inPoly = !inPoly;
                        }
                    }

                    j = i;
                }
            }

            return inPoly;
        };
    }

    if (!google.maps.Circle.prototype.containsLatLng) {
        google.maps.Circle.prototype.containsLatLng = function(latLng) {
            if (google.maps.geometry) {
                return google.maps.geometry.spherical.computeDistanceBetween(this.getCenter(), latLng) <= this.getRadius();
            }
            else {
                return true;
            }
        };
    }

    google.maps.LatLngBounds.prototype.containsLatLng = function(latLng) {
        return this.contains(latLng);
    };

    google.maps.Marker.prototype.setFences = function(fences) {
        this.fences = fences;
    };

    google.maps.Marker.prototype.addFence = function(fence) {
        this.fences.push(fence);
    };

    google.maps.Marker.prototype.getId = function() {
        return this['__gm_id'];
    };

    //==========================
    // Array indexOf
    // https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Array/indexOf
    if (!Array.prototype.indexOf) {
        Array.prototype.indexOf = function (searchElement /*, fromIndex */ ) {
            "use strict";
            if (this == null) {
                throw new TypeError();
            }
            var t = Object(this);
            var len = t.length >>> 0;
            if (len === 0) {
                return -1;
            }
            var n = 0;
            if (arguments.length > 1) {
                n = Number(arguments[1]);
                if (n != n) { // shortcut for verifying if it's NaN
                    n = 0;
                } else if (n != 0 && n != Infinity && n != -Infinity) {
                    n = (n > 0 || -1) * Math.floor(Math.abs(n));
                }
            }
            if (n >= len) {
                return -1;
            }
            var k = n >= 0 ? n : Math.max(len - Math.abs(n), 0);
            for (; k < len; k++) {
                if (k in t && t[k] === searchElement) {
                    return k;
                }
            }
            return -1;
        }
    }

    return GMaps;
}));


// show and hide menu on button click
$('#btn-mobile-menu').on('click', function(){

    $('.main-nav').fadeToggle(300, function(){
        if ( $('.main-nav').is(':hidden') ) 
        $(this).css('display', '');
    });
});

// hide menu on link click
$('.main-nav a').on('click', function(){
    
    var screenWidth = $(window).width();
    
    if ( screenWidth <= 767 ) {
        var menu = $(this).closest('ul');
        menu.fadeOut(300, function(){
            $('.main-nav').css('display', '');
        });
    }    
});


$(function(){
    
    
// map
var map = new GMaps({
    div: '.map',
    lat: 47.141531,
    lng: 15.523934
});

map.addMarker({
    lat: 47.141531,
    lng: 15.523934,
    title: 'Graz',
    infoWindow: {
        content: '<p>Dr Hofer</p>'
    }
});

// use the map
$('#map-btn').on('click', function(){

    // show and hide transparent cover
    $('.map-cover').toggle();
    $('.map-btn-text').fadeToggle();
});
    
});    
// animate on scroll

$(window).on('scroll load', function(){

    var line = $(window).scrollTop(); 
    
    // exsicute this code only on main page 
    if ( $('body').is('#aktuelles') ) {
        $('nav').addClass('fix-nav');
    }else {
        if ( line >= 300 ) {
            $('nav').addClass('fix-nav');
        }else { $('nav').removeClass('fix-nav'); }
    }    
});

var offerData = [
	{
		id: 1,
		title: 'Erstuntersuchung & Beratung',
		image: 'img/offer1.jpg',
		description: 'Ein herzliches ‚ÄûGr√º√ü Gott‚Äú erwartet Sie in unserer Ordination! Denn eine vertrauensvolle Arzt-Patientenbeziehung ist uns wichtig; ebenso eine genaue Untersuchung und Diagnostik Ihrer Zahngesundheit ‚Äì denn die ganze Diagnose ist schon die halbe Therapie! Bei dieser Erstuntersuchung werden etwaige Behandlungsnotwendigkeiten erhoben ‚Äì klinisch als auch radiologisch: Karies, Parodontitis, funktionelle oder √§sthetische Probleme. Eine umfassende Aufkl√§rung √ºber Ihre Diagnose und notwendige Behandlungen beziehungsweise Behandlungsm√∂glichkeiten erfolgt; Therapieziele werden festgelegt. Auch Ihre Anliegen / W√ºnsche / Sorgen oder √Ñngste sind ein fixer Bestandteil von diesem pers√∂nlichen Gespr√§ch. Erst danach wird f√ºr Sie ein individueller Behandlungsplan erstellt und mit der zahn√§rztlichen Therapie begonnen.'
	},
	{
		id: 2,
		title: 'Prophylaxe & Professionelle Zahnreinigung',
		image: 'img/offer2.jpg',
		description: '‚ÄûVorbeugen ist besser als Heilen" (Hippokrates, 400 v. Chr.) - der Erhalt der Gesundheit hat immer die h√∂chste Priorit√§t! Deswegen ist Prophylaxe eine zentrale S√§ule in unserem Behandlungskonzept. Durch die kompetente Anleitung von unseren Assistentinnen optimieren wir Ihre Hygienef√§higkeit und entfernen sanft harten (Zahnstein) sowie weichen Zahnbelag (Plaque) bei einer professionellen Zahnreinigung / Mundhygiene. Wir legen gr√∂√üten Wert darauf Ihnen zu zeigen, wie und womit Sie Ihre Z√§hne sauber halten k√∂nnen! Das frische Gef√ºhl und strahlende L√§cheln nach einer Mundhygiene wird Ihnen lange erhalten bleiben und ist ein wichtiger Baustein Ihre Zahngesundheit ein Leben lang zu erhalten. Denn ein sauberer Zahn wird nicht krank!'
	},
	{
		id: 3,
		title: 'Parodontitistherapie',
		image: 'img/offer3.jpg',
		description: 'Neben Karies ist Parodontitis die h√§ufigste Ursache f√ºr Zahnverlust. Die Parodontitis ist eine entz√ºndliche Erkrankung des Zahnhalteapparates. Das erste Symptom ist oft Zahnfleischbluten, doch in der Tiefe wird Kieferknochen und Bindegewebe um den Zahn abgebaut - es bildet sich eine Zahnfleischtasche. Unbehandelt f√ºhrt diese chronische Erkrankung zu Zahnlockerung und Zahnverlust! Durch eine genaue Diagnostik l√§sst sich eine Parodontitis fr√ºhzeitig erkennen, wodurch diese effektiv und erfolgreich therapiert werden kann. Auch bei gravierenden Ausgangsbefunden sind durch eine konsequente, zeitgem√§√üe Therapie oft eine Stabilisierung und damit ein langfristiger Zahnerhalt m√∂glich! Aber auch aus allgemeinmedizinischer Sicht ist eine Diagnose und Therapie von gro√üer Bedeutung: So haben Studien gezeigt, dass ein Zusammenhang zwischen Parodontitis und Herzerkrankungen, sowie Diabetes und Fr√ºhgeburten besteht!'
	},
	{
		id: 4,
		title: 'Mikroskopische Endodontie',
		image: 'img/offer4.jpg',
		description: 'Die Endodontie ist der Teilbereich der Zahnmedizin, der sich mit Erkrankungen des Zahninneren (Pulpa-Dentin-Komplex, ‚ÄûZahnnerv‚Äú) und des die Wurzel umgebenden Gewebes besch√§ftigt. Die Endodontie ist meine gro√üe Leidenschaft! Die Behandlung Ihres Zahnes erfolgt unter dem Mikroskop (=mikroskopische Endodontie), zusammen mit modernstem Equipment, know-how, viel Feingef√ºhl und Geduld. Neben Erstbehandlungen sind wir Ihr Ansprechpartner f√ºr Revisionen (Wiederholung einer erfolglosen Wurzelbehandlung) ‚Äì f√ºr sogenannte Problemz√§hne. Unser Ziel ist immer der Erhalt Ihres Zahnes! Diese Spezialisierung wird auch von vielen Zahn√§rzten in Form von Zuweisungen an die Zweitordination im <a href="http://www.zahnatelier.at/index.php?c=44&l=deu">Zahnatelier</a> Prof. Polansky in Graz (Praxis ausschlie√ülich f√ºr mikroskopische Endodontie) genutzt.'
	},
	{
		id: 5,
		title: '√Ñsthetische Zahnmedizin',
		image: 'img/offer5.jpg',
		description: 'Sch√∂ne wei√üe Z√§hne und somit ein strahlendes, freundliches und gesundes L√§cheln sind ein Zeichen von Vitalit√§t! Der oft entscheidende erste Eindruck wird dadurch gepr√§gt! Dunkle Kronenr√§nder oder schwarze Amalgamf√ºllungen sind √§sthetisch st√∂rend und sollten der Vergangenheit angeh√∂ren. Hoch biokompatible, zahnfarbene F√ºllungsmaterialien haben diese inzwischen mehr als ersetzt. Das Bleichen (bleaching) der gesamten Zahnreihe oder von einzelnen wurzelbehandelten Z√§hnen (internal bleaching) entfernt unsch√∂ne Diskolorationen. Mittels hauchd√ºnnen, lichtdurchl√§ssigen Keramikschalen (Veneers) k√∂nnen Z√§hne in Form und Farbe ver√§ndert werden, sodass ein harmonisches L√§cheln entsteht! Ihr perfektes L√§cheln ist unser Ansporn!'
	},
	{
		id: 6,
		title: 'Vollkeramische Restaurationen',
		image: 'img/offer6.jpg',
		description: 'Die Natur ist unser Vorbild! Durch die Verwendung von reiner Keramik als Restaurationsmaterial ist eine Unterscheidung vom nat√ºrlichen Zahn ‚Äì wenn √ºberhaupt - nur mehr f√ºr das geschulte Auge m√∂glich. Farbe, Form, Transluzenz und Fluoreszenz in nat√ºrlicher Vollendung! Aber auch hinsichtlich Biokompatibilit√§t sind metallfreie Restaurationen un√ºbertroffen: Ein entz√ºndungsfreien Restaurationsrand sorgt f√ºr einen gesunden Zahnhalteapparat und dadurch f√ºr langfristig gesunde Z√§hne! Ein hochqualitativer Herstellungsprozess (CAD ‚Äì CAM) und das intraorale adh√§sive Befestigen erm√∂glicht den Einsatz von Vollkeramik als Inlay/Onlay (bei gro√üen F√ºllungen), sowie Kronen und Br√ºcken auf eigenen Z√§hnen als auch auf Implantaten. Dauerhaft ‚Äì √Ñsthetisch ‚Äì Biokompatibel = Vollkeramik'
	},
	{
		id: 7,
		title: 'Implantatversorgungen',
		image: 'img/offer7.jpg',
		description: 'Ihre eigenen Z√§hne sind die Besten! Wenn der eigene Zahn aber nicht mehr erhalten werden kann, sind Implantate die 1. Wahl. Ein Implantat ist eine k√ºnstliche Zahnwurzel aus Titan. Eingesetzt in den Kieferknochen, verw√§chst (osseointegriert) es mit diesem. So erh√§lt man neue, k√ºnstliche Zahnwurzeln, die als Ersatz f√ºr einzelne oder mehrere Z√§hne (Implantatbr√ºcke) dienen. Auf vier beziehungsweise sechs Implantaten versorgen wir full-arch Restaurationen im zahnlosen Kiefer und k√∂nnen so Prothesen vermeiden und Lebensqualit√§t schenken. Gro√üen Wert legen wir auf die Nachsorge unserer Implantate: Regelm√§√üige Prophylaxe durch unser Recallsystem sorgt f√ºr ein langfristig gesundes periimplant√§res Gewebe!'
	},
	{
		id: 8,
		title: 'Prothetische Zahnheilkunde',
		image: 'img/offer8.jpg',
		description: 'Fehlende Z√§hne k√∂nnen festsitzend oder abnehmbar ersetzt werden. Es k√∂nnen medizinische oder auch pers√∂nliche Gr√ºnde vorliegen, die f√ºr die Anfertigung eines abnehmbaren Zahnersatzes sprechen. Die Kunststoffprothese als Sofortprovisorium im Notfall, die Totalprothese im zahnlosen Kiefer oder die Metallger√ºstprothese als Zahnersatz im teilbezahnten Gebiss. Die Ausf√ºhrungsm√∂glichkeiten sind vielseitig aber die Vorteile sind dieselben: Eine bessere Hygienef√§higkeit insbesondere im h√∂heren Alter, die M√∂glichkeit der extraoralen Bearbeitung und die Mitfinanzierung durch die √∂ffentlichen Krankenkassen.'
	},
	{
		id: 9,
		title: 'Kinderfreundliche Behandlung',
		image: 'img/offer9.jpg',
		description: 'Regelm√§√üige Kontrollen ab dem Kindesalter (ab ca. 3 Jahren), gute Zahnpflege von Mama oder Papa und eine ausgewogene Ern√§hrung sind der Schl√ºssel zum Erfolg! So k√∂nnen wir die Milchz√§hne und die ab dem 6.Lebensjahr durchbrechenden bleibenden Z√§hne Ihres Kindes ‚Äì OHNE BOHREN - gesund erhalten. Karies zu vermeiden ist die oberste Pr√§misse. Gesunde Z√§hne von Anfang an ‚Äì ein Leben lang! Sollte sich trotzdem einmal das Kariesteufelchen einschleichen, so wird dieses nach einer kindsgerechten Aufkl√§rung (show ‚Äì tell ‚Äì do) mit sehr viel Einf√ºhlungsverm√∂gen vertrieben. Der erste Zahnarztbesuch soll eine positive Erfahrung sein und pr√§gt die Zahngesundheit Ihres Kindes von morgen!'
	}
]

// cahnge data on click - Leistungen
$('#offer-menu h3').on('click', function(){
	
	var leistungID =  parseInt($(this).attr('id').slice(-1));
	
	$.each(offerData, function(id, obj){
		
		if ( (leistungID-1) == id) {

			var el = '<img src="'+obj.image+'" alt="'+obj.title+'"><h3>'+obj.title+'</h3><p>'+obj.description+'</p>';

			$('.offer-data-container').html('');
			$('.offer-data-container').append(el);			
		}
	});
});


// smooth scrolling
$(function() {
    $('a[href*="#"]:not([href="#"])').click(function() {
        if (location.pathname.replace(/^\//,'') == this.pathname.replace(/^\//,'') && location.hostname == this.hostname) {
            var target = $(this.hash);
            target = target.length ? target : $('[name=' + this.hash.slice(1) +']');
            if (target.length) {
                $('html, body').animate({
                    scrollTop: target.offset().top
                }, 1000);
                return false;
            }
        }
    });
});
  
var images = new Array();

function preload() {
    for (i = 0; i < preload.arguments.length; i++) {
        images[i] = new Image();
        images[i].src = preload.arguments[i];
    }
}

preload('img/gal1-big.jpg', 'img/gal2-big.jpg', 'img/gal3-big.jpg', 'img/gal4-big.jpg', 
	    'img/gal5-big.jpg', 'img/gal6-big.jpg', 'img/offer1.jpg',
	    'img/offer2.jpg', 'img/offer3.jpg', 'img/offer4.jpg', 'img/offer5.jpg');

// animate on scroll
function animate(element, position, value, offsetBottom, animePos, animeVal, time) {

    var elTop = $(element).offset().top;
    var newElTop = parseInt(elTop + offsetBottom);
    var stopIf = false;

    $(element).css('opacity', '0');
    $(element).css('transition', 'all ' +time+ ' ease-in-out');
    $(element).css('-webkit-transition', 'all ' +time+ ' ease-in-out');
    $(element).css('position', 'relative');
    $(element).css(position, value);

    $(window).on('scroll load', function(){

        var line = $(window).scrollTop() + $(window).height();

        if ( line >= newElTop && stopIf === false) {
            $(element).css('opacity', '1');
            $(element).css(animePos, animeVal);
            stopIf = true;
        }
    });

}

function runAnimations(offS1, offS2, offS3, offS4, offS5, offS6) {

    // animate(element, position, value, offsetBottom, animePos, animeVal, time)
    animate('#animate-info', 'top', '70px', offS1, 'top', '0px', '1s');
    animate('#animate-team', 'top', '70px', offS2, 'top', '0px', '1s');
    animate('#animate-video', 'right', '70px', offS3, 'right', '0px', '1s');
    animate('#animate-list', 'left', '70px', offS4, 'left', '0px', '1s');
    setTimeout(function(){ animate('#animate-gal', 'top', '70px', offS5, 'top', '0px', '1s'); }, 500);
    animate('#animate-form', 'top', '70px', offS6, 'top', '0px', '1s');
}

function responsiveAnimations() {

    var windowWidth = $(window).height();

    if ( windowWidth < 450 ) { runAnimations(-100, -150, -100, -100, -100, 450) }
    else if ( windowWidth < 767 ) { runAnimations(100, 50, 100, 100, 100, 100) }
    else if ( windowWidth < 1023 ) { runAnimations(200, 500, 200, 200, 400, 600) }
    else if ( windowWidth < 1200 ) { runAnimations(600, 650, 500, 500, 400, 700) }
    else if ( windowWidth > 1200 ) { runAnimations(800, 900, 600, 600, 800, 1000) }
}

if( $('body').is('#sroll-home') ) { responsiveAnimations(); }


$('.team-box').on('click', function(e){
    
    if ( $('.person-info').is(':hidden') ) {

        var info = $(this).find('.person-info');
        var allInfo = $('.person-info');
        
        allInfo.hide();
        info.fadeIn(300);
    }
    
    // hide all info divs by click on section(background)
    $('section').on('click', function(e){
        if ( e.target == this ) { 
            if (allInfo.is(':visible')) {
                e.stopPropagation();
                allInfo.hide();
            }
            
        }
    });
});

// donwload cv
$('#lebenslauf').on('click', function(e){
    

    if ( $('.person-info').is(':visible') ) { 
       
        setTimeout(function(){
            $('.person-info').hide(300);
        },500);
    }

    $('.hofer-tras-back').fadeIn(300);
    
});

$('.hofer-tras-back, .diploma-big-trans').on('click', function(e){

    if ( e.target == this ) {
        $(this).fadeOut(300);
    }
});

$('#close-cv').on('click', function(){ $('.hofer-tras-back').fadeOut(300)});


$('.diploma').on('click', function(){

    $('.hofer-tras-back').fadeOut(300);
    $('.diploma-big-trans').fadeIn(300);
});


$('#close-cv-big').on('click', function(){ $('.diploma-big-trans').fadeOut(300); });


$(window).on('resize load', function(){
	//934

	if ( $(this).width() <= 934 ) {
		//$('.person-info').remove();
	}
	
	
});